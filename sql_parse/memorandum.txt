在阅读mysql的代码时，发现mysql的SQL语法分析和服务器环境结合的非常紧密，这背离了高内聚低耦合的原则。在修改mysql的代码时，这种糅合在一起的代码也确实导致新手修改上的困难。

如果把代码的高内聚和低耦合看成流水线或者社会分工。就如同随着社会的发展，分工变得越来越细，随着代码的发展，这种分工也会越来越细致。这在我做java开发的过程中感受很多，函数很短小，调用层级增多。从我的观点看，函数式语言是这种思路在程序编写形式上的一个极致。

所以，单独拆分出sql_parse这一模块，该模块仅提供lsql的标准语法的解析，并生成对应的语法结构。

这样语法分析将独立存在，为任何需要它的模块提供功能。至于具体环境下的特定处理，将由该环境决定，而不是在语法分析时决定。

很早以前学习语法分析时，语法树的概念深入人心。这是一种通过递归来表达语法内容内容方式，分析结果的存储和语法定义产生一种对应关系。

如：
  root
 /  |  \
l1  l1  l1
|   |   |
l2  l2  l2

的语法定义产生同样语法结构。这种方式具有很广泛的适用性。

但这种方式在具体的开发中带来了很多的不便，个人认为只有那些像冯.诺依曼那样具有超级大脑的人可以在头脑中迅速展开这些结构。

对于这样一段SQL
create table t1 (f1 int, f2 int);
远不需要这样的树形递归表达。

当分析结束后，所需要知道的仅仅是这是一个建表语句，表的名字和列相关信息。
所以通过如下的定义，不论在程序的编写中，还是在调试过程中，都简单直接。
struct sql_create_table
{
  char *table_name;
  list<field> fields;
};

这是一种降低维度的，可读性较好的模式。所以lsql的语法分析结果将以这种方式表示。



